#!/usr/bin/env python3
# Checks the SMIRNOFF parameter coverage of a "random" subset of molecules from a
# given molecule file. Run with -h flag for usage.

import argparse
import json
import logging
import random
from collections import defaultdict

from openeye import oechem
from openforcefield.topology import Molecule, Topology

import utilize_params_util

#
# Constants
#

EMOLECULES_TOTAL_COUNT = 22327838

#
# Command line flags
#


def parse_commandline_flags() -> {str: "argument value"}:
    """Uses argparse to parse all command line flags"""
    logging.info("Parsing command line flags")

    parser = argparse.ArgumentParser(
        description=(
            "Checks the SMIRNOFF parameter coverage of a \"random\" subset of "
            "molecules from a given molecule file. Generates two data files: "
            "params_by_molecule.json tells the paramaters associated with each "
            "molecule, and param_ids.json lists all the parameters used by the "
            "given molecules. Use the --start and --end index flags to split "
            "the random sample across multiple jobs"),
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument(
        "-f",
        metavar="MOLECULE FILE",
        help="File containing molecules to select")
    parser.add_argument(
        "-t",
        default=-1,
        metavar="INT",
        type=int,
        help="Total number of molecules in the file - leave blank if unknown")
    parser.add_argument(
        "-n",
        default=1000000,
        metavar="INT",
        type=int,
        help="The number of molecules to select")
    parser.add_argument(
        "-s",
        default=5,
        metavar="INT",
        type=int,
        help="Seed for making the random sample")
    parser.add_argument(
        "--start",
        default=0,
        metavar="IDX",
        type=int,
        help="Start index to use in the random sample (inclusive, 0-based)")
    parser.add_argument(
        "--end",
        default=1000000,
        metavar="IDX",
        type=int,
        help="End index to use in the random sample (inclusive, 0-based)")
    parser.add_argument(
        "-d",
        default=".",
        metavar="DIRECTORY",
        help="The directory to save data generated by the script")

    return vars(parser.parse_args())


#
# File-handling utilities
#


def count_total_molecules(filename: str) -> int:
    """Counts number of molecules in a file"""
    logging.info("Counting total molecules in file %s", filename)
    total = 0
    ifs = oechem.oemolistream(filename)
    mol = oechem.OEMol()
    while oechem.OEReadMolecule(ifs, mol):
        total += 1
        if total % 10000 == 0:
            logging.info("Counting molecule %d", total)
    logging.info("Counted %d molecules in %s", total, filename)
    return total


def read_index_mols_from_file(filename: str, indices: set) -> \
        (oechem.OEMol, int):
    """Generates the molecules at the given indices in the given file"""
    with open(filename, "r") as ifs:
        index = 0
        for line in ifs:
            if index in indices:
                smiles = line.split(".")[0]
                mol = oechem.OEMol()
                oechem.OESmilesToMol(mol, smiles)
                yield mol, index
            index += 1


def save_data_to_json(directory, params_by_molecule, param_ids):
    """Saves the given data to JSON"""
    with open(f"{directory}/params_by_molecule.json", "w") as pm_file:
        json.dump(params_by_molecule, pm_file)
    with open(f"{directory}/param_ids.json", "w") as pid_file:
        json.dump(list(param_ids), pid_file)


#
# Other utilities
#


def verify_indices(start: int, end: int, n: int):
    """Verifies that the indices for the random sample are correct.
    Raises an AssertionError if they are not.
    """
    assert start >= 0 and end >= 0, "Indices must be at least 0"
    assert start < n and end < n, "Indices must be less than n"
    assert end >= start, "End must be after start"


#
# Parameter functions
#


def pretty_param_string(param_ids: "collection") -> str:
    """Creates a nice string showing the parameters in the given collection"""
    return ' '.join(sorted(param_ids, key=utilize_params_util.order_param_id))


def get_smirnoff_params(mol: oechem.OEMol) -> {"id": ["atom_indices"]}:
    """For the given molecule, finds the SMIRNOFF params and their atom indices"""
    off_mol = Molecule.from_openeye(mol, allow_undefined_stereo=True)
    try:
        topology = Topology.from_molecules(off_mol)
    except Exception as e:
        return {}
    molecule_force_list = utilize_params_util.SMIRNOFF.label_molecules(topology)

    params = defaultdict(list)
    for force_tag, force_dict in molecule_force_list[0].items():
        for (atom_index, parameter) in force_dict.items():
            params[parameter.id].append(atom_index)

    return params


def find_parameter_ids(filename: str, indices: set) -> \
        ({int : {"smiles": str, "ids": {"id": ["atom_indices"]}}}, set):
    """Finds the SMILES parameter ids associated with the molecule at each index
    Returns:
        - params_by_molecule: mapping from molecule indices to SMILES string and
            parameter ids
        - param_ids: set of all parameter ids found
    """
    logging.info("Finding parameters for molecules")

    params_by_molecule = {}
    param_ids = set()

    for mol, index in read_index_mols_from_file(filename, indices):
        oechem.OEAddExplicitHydrogens(mol)

        smiles = oechem.OECreateIsoSmiString(mol)
        logging.info("Looking at molecule %d => %s", index, smiles)

        params = get_smirnoff_params(mol)
        logging.info("Parameter IDs: %s", list(params.keys()))

        param_ids |= params.keys()

        params_by_molecule[index] = {
            "smiles": smiles,
            "ids": params,
        }

    return params_by_molecule, param_ids


def find_non_covered_params(param_ids, ff):
    """Finds the set of parameters in SMIRNOFF not covered by the given set"""
    smirnoff_ids = utilize_params_util.find_smirnoff_params(ff)
    non_covered = smirnoff_ids - param_ids
    return non_covered


#
# Execution
#


def main():
    # Configuration
    logging.getLogger().setLevel(logging.INFO)
    args = parse_commandline_flags()

    # Find (0-based) indices for sample
    total_molecules = count_total_molecules(args["f"]) \
                        if args["t"] < 0 else args["t"]
    random.seed(args["s"])
    verify_indices(args["start"], args["end"], args["n"])
    indices_list = random.sample(range(total_molecules),
                                 args["n"])[args["start"]:args["end"] + 1]
    indices = set(indices_list)

    # Grab molecules and find parameters
    params_by_molecule, param_ids = find_parameter_ids(args["f"], indices)
    non_covered_params = find_non_covered_params(param_ids,
                                                 utilize_params_util.SMIRNOFF)

    # Save data
    save_data_to_json(args["d"], params_by_molecule, param_ids)

    # Calculate coverage
    logging.info("Covered params (%d): %s", len(param_ids),
                 pretty_param_string(param_ids))
    logging.info("Non-covered params (%d): %s", len(non_covered_params),
                 pretty_param_string(non_covered_params))


if __name__ == "__main__":
    main()
